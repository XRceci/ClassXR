---
title: XR Lab 6
author: Yawen Li
date: 2024-01-29
category: XR
layout: post
mermaid: true
---

## What is FlyRing Selection?

Last week, we proposed two VR selection techniques for a supermarket scenario, and we decided to go with FlyRing Selectionâ€”sounds cool, right? This technique is all about creating a fancy yet efficient way to select and inspect items in VR.

![Image 08](https://github.com/XRceci/ClassXR/raw/master/assets/image/250114/08.png)

Here's the idea: use a ray to select a group of items from afar, and they magically fly toward you, forming a circular arrangement around you. You can then rotate the circle to examine each item up close, effortlessly and intuitively. It's like having your own futuristic carousel of products at your fingertips!

Now, it's time to bring FlyRing Selection to life. Let's  make it happen! ðŸš€



# Implementation

## 1 - First, Let's walk !

We should provide our user with the ability to explore the supermarket to check out what they like, we need to be able to walk!

for that, we can use the left joy stick by getting the input from `PrimaryThumbstick`, where "Primary" is the left hand controller.

the "forward" and "right" directions should depend on where the user is looking, so we get where the camera is pointing at

then we calculate how much the user should move and we apply this transformation to our `cameraRig`'s position depending on the `moveSpeed` that we want .

```C#
Â  Â  private void HandleMovement() 
Â  Â  {
Â  Â  Â  Â  Vector2 joystickInput = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
Â  Â  Â  Â  if (joystickInput.magnitude > 0.1f) 
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  // Get forward and right directions from the camera
Â  Â  Â  Â  Â  Â  Vector3 forward = Camera.main.transform.forward;
Â  Â  Â  Â  Â  Â  Vector3 right = Camera.main.transform.right;
Â  Â  Â  Â  Â  Â  // Remove vertical component for horizontal-only movement
Â  Â  Â  Â  Â  Â  forward.y = 0;
Â  Â  Â  Â  Â  Â  right.y = 0;
Â  Â  Â  Â  Â  Â  forward.Normalize();
Â  Â  Â  Â  Â  Â  right.Normalize();
Â  Â  Â  Â  Â  Â  // Calculate and apply movement
Â  Â  Â  Â  Â  Â  Vector3 moveDirection = (forward * joystickInput.y + right * joystickInput.x);
Â  Â  Â  Â  Â  Â  cameraRig.transform.position += moveDirection * moveSpeed * Time.deltaTime;
Â  Â  Â  Â  }
Â  Â  }
```

## 2 - Pre-Selection
### 2.1 - Ray casting

Our technique begins by allowing users to point at objects using ray casting from their right controller. First we create a visual representation of the ray using Unity's `LineRenderer`:

```C#
private LineRenderer lineRenderer;
private void Start()
{   
    // Initialize line renderer for visual feedback
    lineRenderer = rightController.GetComponent<LineRenderer>();
    if (lineRenderer == null)
    {
        lineRenderer = rightController.AddComponent<LineRenderer>();
        lineRenderer.startWidth = 0.01f;
        lineRenderer.endWidth = 0.01f;
        lineRenderer.material = new Material(Shader.Find("Unlit/Color"));
        lineRenderer.material.color = Color.red;
    }
}
```

In our `HandleObjectAttraction` method, we continuously update the ray's position and direction:
```C#
// Update visual ray
lineRenderer.SetPosition(0, controllerTransform.position);
lineRenderer.SetPosition(1, controllerTransform.position + controllerTransform.forward * raycastDistance);
```

Since we want to be able to detect even occluded objects, we use 3. we use `Physics.RaycastAll` to detect all objects along the ray:
```C#
RaycastHit[] hits = Physics.RaycastAll(controllerTransform.position, 
                                     controllerTransform.forward, 
                                     raycastDistance);
```

the array `RaycastHit[]` will contain all the objects that has been detected along the ray

### Video Demonstration

<div style="text-align: center;">
  <iframe width="800" height="450" 
      src="https://www.youtube.com/watch?v=KMfF3RTDvz4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
  </iframe>
</div>


### 2.2 - Bringing Objects Closer and make a circle!

Once we've detected all objects along the ray, we need to bring them closer to the user and arrange them in a circle for easier selection. This happens when the user pulls the trigger.

First, we store the original positions of all detected objects so we can return them later:
```C#
foreach (RaycastHit hit in hits)
{
    GameObject hitObject = hit.collider.gameObject;
    if (!activeObjects.Contains(hitObject))
    {
        activeObjects.Add(hitObject);
        if (!originalPositions.ContainsKey(hitObject))
        {
            // Store original position and material
            originalPositions[hitObject] = hitObject.transform.position;
            MeshRenderer renderer = hitObject.GetComponent<MeshRenderer>();
            originalMaterials[hitObject] = renderer.material;
        }
    }
}
```

Then we arrange the objects in a circle, for that we have an `ArrangeObjectsInCircle` method:

```C#
private void ArrangeObjectsInCircle()
{
    Transform controllerTransform = rightController.transform;
    // Calculate the center point of the circle in front of the controller
    Vector3 centerPoint = controllerTransform.position + controllerTransform.forward * circleDistance;
    
    // Calculate angle step for even distribution
    float angleStep = 360f / activeObjects.Count;
    
    // Position each object around the circle
    for (int i = 0; i < activeObjects.Count; i++)
    {
        float angle = i * angleStep * Mathf.Deg2Rad;
        Vector3 targetPosition = centerPoint + new Vector3(
            Mathf.Sin(angle) * circleRadius,  // X position
            0,                                // Keep Y position constant
            Mathf.Cos(angle) * circleRadius   // Z position
        );

        // Smoothly move object to target position
        activeObjects[i].transform.position = Vector3.Lerp(
            activeObjects[i].transform.position,
            targetPosition,
            Time.deltaTime * attractionSpeed
        );
    }
}
```

- `circleDistance`: Controls how far in front of the user the circle appears
- `circleRadius`: Determines the size of the circle
- `attractionSpeed`: Controls how quickly objects move to their positions

Objects are evenly spaced around the circle by calculating `angleStep`, and we use `Vector3.Lerp` to get a smooth movement animation



### Video Demonstration

<div style="text-align: center;">
  <iframe width="800" height="450" 
      src="https://www.youtube.com/watch?v=QU2OhqSekmY" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
  </iframe>
</div>
