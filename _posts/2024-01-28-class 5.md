---
title: XR Lab 6
author: Yawen Li
date: 2024-01-29
category: XR
layout: post
mermaid: true
---

## What is FlyRing Selection?

Last week, we proposed two VR selection techniques for a supermarket scenario, and we decided to go with FlyRing Selectionâ€”sounds cool, right? This technique is all about creating a fancy yet efficient way to select and inspect items in VR.

![Image 08](https://github.com/XRceci/ClassXR/raw/master/assets/image/250114/08.png)

Here's the idea: use a ray to select a group of items from afar, and they magically fly toward you, forming a circular arrangement around you. You can then rotate the circle to examine each item up close, effortlessly and intuitively. It's like having your own futuristic carousel of products at your fingertips!

Now, it's time to bring FlyRing Selection to life. Let's  make it happen! ðŸš€



# Implementation

## 1 - First, Let's walk !

We should provide our user with the ability to explore the supermarket to check out what they like, we need to be able to walk!

for that, we can use the left joy stick by getting the input from `PrimaryThumbstick`, where "Primary" is the left hand controller.

the "forward" and "right" directions should depend on where the user is looking, so we get where the camera is pointing at

then we calculate how much the user should move and we apply this transformation to our `cameraRig`'s position depending on the `moveSpeed` that we want .

```C#
Â  Â  private void HandleMovement() 
Â  Â  {
Â  Â  Â  Â  Vector2 joystickInput = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
Â  Â  Â  Â  if (joystickInput.magnitude > 0.1f) 
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  // Get forward and right directions from the camera
Â  Â  Â  Â  Â  Â  Vector3 forward = Camera.main.transform.forward;
Â  Â  Â  Â  Â  Â  Vector3 right = Camera.main.transform.right;
Â  Â  Â  Â  Â  Â  // Remove vertical component for horizontal-only movement
Â  Â  Â  Â  Â  Â  forward.y = 0;
Â  Â  Â  Â  Â  Â  right.y = 0;
Â  Â  Â  Â  Â  Â  forward.Normalize();
Â  Â  Â  Â  Â  Â  right.Normalize();
Â  Â  Â  Â  Â  Â  // Calculate and apply movement
Â  Â  Â  Â  Â  Â  Vector3 moveDirection = (forward * joystickInput.y + right * joystickInput.x);
Â  Â  Â  Â  Â  Â  cameraRig.transform.position += moveDirection * moveSpeed * Time.deltaTime;
Â  Â  Â  Â  }
Â  Â  }
```

## 2 - Pre-Selection
### 2.1 - Ray casting

Our technique begins by allowing users to point at objects using ray casting from their right controller. First we create a visual representation of the ray using Unity's `LineRenderer`:

```C#
private LineRenderer lineRenderer;
private void Start()
{   
    // Initialize line renderer for visual feedback
    lineRenderer = rightController.GetComponent<LineRenderer>();
    if (lineRenderer == null)
    {
        lineRenderer = rightController.AddComponent<LineRenderer>();
        lineRenderer.startWidth = 0.01f;
        lineRenderer.endWidth = 0.01f;
        lineRenderer.material = new Material(Shader.Find("Unlit/Color"));
        lineRenderer.material.color = Color.red;
    }
}
```

In our `HandleObjectAttraction` method, we continuously update the ray's position and direction:
```C#
// Update visual ray
lineRenderer.SetPosition(0, controllerTransform.position);
lineRenderer.SetPosition(1, controllerTransform.position + controllerTransform.forward * raycastDistance);
```

Since we want to be able to detect even occluded objects, we use 3. we use `Physics.RaycastAll` to detect all objects along the ray:
```C#
RaycastHit[] hits = Physics.RaycastAll(controllerTransform.position, 
                                     controllerTransform.forward, 
                                     raycastDistance);
```

the array `RaycastHit[]` will contain all the objects that has been detected along the ray





## Video Demonstration

<div style="text-align: center;">
  <iframe width="800" height="450" 
      src="https://www.youtube.com/embed/WGSwOAnNJhY" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
  </iframe>
</div>
